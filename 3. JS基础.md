# 类型
## null 是对象嘛？
## 对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？
## typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么？
## 加法的计算规则
    除了加法，剩下的都是
# why'[] == []' return false? why'[] == ![]' return true? 
# 什么是闭包？
# 什么是浅/深拷贝？如何实现？
# 讲一下原型链？//需要补充
# 什么是暂时性死区？


# 面向对象
## 继承

1. `constructor`属性在构造函数的prototype属性对象上，指向构造函数本身
实例将会继承`constructor`<br>
`实例.constructor===构造函数.prototype.constructor`

2. `instanceOf`的原理
    ```js 
    fish instanceof Animal
    ```
    ===
    ```js 
    Animal.prototype.isPrototypeOf(fish)
    ```
    - 会检查整个原型链
    - 除了null和undefine,其他`对象`instanceof object 都是True
    - 对原始类型不成立
    ```js
    123 instanceof Object
    //false 对原始类型不成立
    [123,456] instanceof Object
    //true
    undefined instanceof Object
    //false
    ```

# 异步操作
## 事件循环
浏览器是多线程，js是单线程<br>
有些线程是常驻线程<br>
如：GUI渲染、js引擎、浏览器事件线程(onclick)
<br>
有些线程当他被用到的时候才会调用<br>
如：定时器、http异步、事件循环处理线程<br>
遵循先同步后异步的原则，下图的同步任务会先跑，异步任务放在各自的线程中，等同步任务全都跑完，异步任务在指定的时间时就会被加载到任务队列，然后进入栈中。
![](imgs/eventloop.png)


## 定时器
1. 定时器中的回调函数如果是对象的方法，则指向全局环境而不是该对象<br>
解决办法：使用bind
    ```js
    var x = 1;

    var obj = {
    x: 2,
    y: function () {
        console.log(this.x);
    }
    };

    setTimeout(obj.y, 1000)
    //1

    setTimeout(obj.y.bind(obj), 1000)
    // 2
    ```

2. setTimeout执行1次，setInterval,无限次每隔ms执行<br>
都会返回定时器编号，clearTimeout(id1);clearInterval(id2);可以取消定时器
3. 原理
    <br>是将指定的代码移出本轮`事件循环`，等到下一轮事件循环，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就继续等待。
    <br>必须等到本轮事件循环的所有同步任务都执行完，才会开始执行。
4. setTimeout(f,0)
    执行完当前的事件循环后，尽早地执行f

### 应用：防抖与节流
解决的问题：短时间内频繁触发某个操作（比如Ajax通信）<br>
都是让某个时间期限内，事件处理函数只执行一次。
1. 防抖：n秒后再执行该事件，如果等待时间内被再次触发，则重新计时。
2. 节流：技能冷却，触发后，在一段时间内方法失效。
>#TODO 闭包实现

### 引申：重排重绘

重绘(repaint)，改变样式而不影响布局。损耗少。<br>
重排（layout），又叫回流需要重新计算和布局。开销大。

重排一定会引起重绘，反之不一定。
为了限制对他们的大量使用，就需要防抖和节流。

